# 4.11 AI Agent 搭建实战

Agent和普通的LLM调用有本质区别：普通调用是"你问一次我答一次"，Agent是"你给我一个目标，我自己决定拆分成哪些步骤、调用哪些工具、怎么把结果拼起来"。

这一章我们用三种方式搭建Agent：Claude Code Agent Teams（蜂群模式）、代码方式（LangGraph）和低代码方式（Dify/Coze），然后聊聊Agent怎么和你现有的系统对接。

## Claude Code Agent Teams 实战

在聊框架之前，先介绍一个你马上就能用的Multi-Agent系统——Claude Code的Agent Teams。它是2026年2月随Opus 4.6发布的功能，让你在终端里就能调度一支AI开发团队。

### 启用

```bash
# 在 ~/.claude/settings.json 中加入
{
  "env": {
    "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1"
  }
}
```

启用后，Claude Code获得TeammateTool能力，可以创建多个Teammate并行工作。

### 核心架构

Agent Teams的架构很清晰：

```
                 ┌──────────┐
                 │ Team Lead│  ← 你跟它对话
                 │ (主实例)  │
                 └────┬─────┘
           ┌──────────┼──────────┐
     ┌─────▼────┐┌────▼─────┐┌──▼──────┐
     │Teammate 1││Teammate 2││Teammate 3│
     │(前端)    ││(后端)    ││(测试)    │
     │worktree-1││worktree-2││worktree-3│
     └──────────┘└──────────┘└──────────┘
```

- **Team Lead** 负责理解需求、分解任务、分配给Teammate、最后合并成果
- **每个Teammate** 拥有独立的上下文窗口和独立的Git Worktree，互不干扰
- Teammate之间通过Team Lead间接协调，不直接通信

### 实战场景：并行开发一个完整功能

假设你要给项目加一个"数据导出"功能，涉及前后端和测试：

```
你: 我需要实现一个数据导出功能，支持导出为CSV和Excel格式。
请分配团队并行处理：
1. 后端：在 app/routers/export.py 实现导出API，支持筛选条件和分页导出
2. 前端：在 src/components/ExportDialog.tsx 实现导出对话框UI
3. 测试：为导出API编写完整的测试用例

请确保后端API的接口格式先确定，前端和测试都基于统一的接口定义。
```

Team Lead会先确定API接口规格，然后创建3个Teammate并行工作。每个Teammate在自己的worktree里写代码，完成后Team Lead合并。

### 成本与适用场景

Agent Teams的Token消耗大约是单Agent的7倍。所以不是什么任务都适合开团队：

- **适合**：涉及3个以上独立模块的大功能、大规模重构、并行修多个独立bug
- **不适合**：简单的单文件修改、高度耦合的模块（并行反而容易冲突）

---

## 用 LangGraph 搭建多步骤 Agent

LangGraph 是 LangChain 团队做的Agent框架，核心思想是把Agent的执行流程建模为一个状态图（Graph）。比起早期LangChain的AgentExecutor，LangGraph对执行流程的控制力强得多，出了问题也好调试。

装依赖：

```bash
pip install langgraph langchain-openai
```

### 场景：自动化代码审查Agent

这个Agent接收一段代码，自动执行：代码风格检查 -> 安全漏洞扫描 -> 性能问题分析 -> 生成审查报告。

```
                    ┌──────────┐
                    │  START   │
                    └────┬─────┘
                         │
                    ┌────▼─────┐
                    │ 代码风格  │
                    │ 检查     │
                    └────┬─────┘
                         │
                    ┌────▼─────┐
                    │ 安全漏洞  │
                    │ 扫描     │
                    └────┬─────┘
                         │
                    ┌────▼─────┐
                    │ 性能问题  │
                    │ 分析     │
                    └────┬─────┘
                         │
                    ┌────▼─────┐
                    │ 生成审查  │
                    │ 报告     │
                    └────┬─────┘
                         │
                    ┌────▼─────┐
                    │   END    │
                    └──────────┘
```

### 核心代码

```python
from typing import TypedDict, Annotated
from langgraph.graph import StateGraph, START, END
from langchain_openai import ChatOpenAI
import operator


# 第一步：定义State —— Agent在执行过程中传递的数据结构
class CodeReviewState(TypedDict):
    code: str                          # 待审查的代码
    language: str                      # 编程语言
    style_issues: list[str]            # 风格问题列表
    security_issues: list[str]         # 安全问题列表
    performance_issues: list[str]      # 性能问题列表
    report: str                        # 最终审查报告


# 初始化LLM
llm = ChatOpenAI(model="gpt-4o", temperature=0.2)


# 第二步：定义Node —— 每个节点是一个处理函数
def check_style(state: CodeReviewState) -> dict:
    """代码风格检查节点"""
    prompt = f"""你是一个代码风格审查专家。检查以下{state['language']}代码的风格问题。
只列出具体的问题，每个问题一行，格式为"行号/位置: 问题描述"。
如果没有问题就回答"无风格问题"。

代码：
```{state['language']}
{state['code']}
```"""

    response = llm.invoke(prompt)
    issues = [
        line.strip()
        for line in response.content.strip().split("\n")
        if line.strip() and line.strip() != "无风格问题"
    ]
    return {"style_issues": issues}


def scan_security(state: CodeReviewState) -> dict:
    """安全漏洞扫描节点"""
    prompt = f"""你是一个安全审计专家。检查以下{state['language']}代码的安全漏洞。
重点关注：SQL注入、XSS、路径遍历、硬编码密钥、不安全的反序列化等。
只列出具体的安全风险，每个一行，格式为"[严重程度] 问题描述"。
严重程度分为：高危、中危、低危。
如果没有安全问题就回答"无安全问题"。

代码：
```{state['language']}
{state['code']}
```"""

    response = llm.invoke(prompt)
    issues = [
        line.strip()
        for line in response.content.strip().split("\n")
        if line.strip() and line.strip() != "无安全问题"
    ]
    return {"security_issues": issues}


def analyze_performance(state: CodeReviewState) -> dict:
    """性能问题分析节点"""
    prompt = f"""你是一个性能优化专家。分析以下{state['language']}代码的性能问题。
关注：时间复杂度、不必要的循环、内存泄漏风险、N+1查询、可优化的数据结构等。
只列出具体的性能问题，每个一行。
如果没有性能问题就回答"无性能问题"。

代码：
```{state['language']}
{state['code']}
```"""

    response = llm.invoke(prompt)
    issues = [
        line.strip()
        for line in response.content.strip().split("\n")
        if line.strip() and line.strip() != "无性能问题"
    ]
    return {"performance_issues": issues}


def generate_report(state: CodeReviewState) -> dict:
    """汇总生成审查报告"""
    style_text = "\n".join(state["style_issues"]) or "无"
    security_text = "\n".join(state["security_issues"]) or "无"
    performance_text = "\n".join(state["performance_issues"]) or "无"

    prompt = f"""根据以下代码审查结果，生成一份简洁的审查报告。

代码语言：{state['language']}

风格问题：
{style_text}

安全问题：
{security_text}

性能问题：
{performance_text}

要求：
1. 先给出整体评级（通过/需修改/需重写）
2. 按优先级列出需要修复的问题
3. 给出具体的修改建议"""

    response = llm.invoke(prompt)
    return {"report": response.content}


# 第三步：构建Graph —— 定义节点和边
def build_review_graph() -> StateGraph:
    graph = StateGraph(CodeReviewState)

    # 添加节点
    graph.add_node("check_style", check_style)
    graph.add_node("scan_security", scan_security)
    graph.add_node("analyze_performance", analyze_performance)
    graph.add_node("generate_report", generate_report)

    # 定义边（执行顺序）
    graph.add_edge(START, "check_style")
    graph.add_edge("check_style", "scan_security")
    graph.add_edge("scan_security", "analyze_performance")
    graph.add_edge("analyze_performance", "generate_report")
    graph.add_edge("generate_report", END)

    return graph.compile()


# 第四步：运行
app = build_review_graph()

result = app.invoke({
    "code": """
import sqlite3

def get_user(username):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    query = f"SELECT * FROM users WHERE username = '{username}'"
    cursor.execute(query)
    result = cursor.fetchone()
    conn.close()
    return result

def process_users():
    users = get_all_users()
    result = []
    for user in users:
        orders = get_orders_by_user(user['id'])
        for order in orders:
            items = get_items_by_order(order['id'])
            result.append({'user': user, 'orders': orders, 'items': items})
    return result
""",
    "language": "python",
    "style_issues": [],
    "security_issues": [],
    "performance_issues": [],
    "report": "",
})

print(result["report"])
```

### 加入条件分支

上面是线性流程，实际场景中你可能需要条件分支。比如，如果有高危安全漏洞就直接打回，不用继续做性能分析了：

```python
def should_continue_after_security(state: CodeReviewState) -> str:
    """根据安全扫描结果决定下一步"""
    has_critical = any("高危" in issue for issue in state["security_issues"])
    if has_critical:
        return "generate_report"  # 有高危漏洞，直接生成报告
    return "analyze_performance"  # 没有高危漏洞，继续分析性能


# 构建Graph时用条件边
graph.add_conditional_edges(
    "scan_security",
    should_continue_after_security,
    {
        "generate_report": "generate_report",
        "analyze_performance": "analyze_performance",
    },
)
```

### 加入工具调用

让Agent能调用外部工具，比如真正运行linter：

```python
from langchain_core.tools import tool
import subprocess


@tool
def run_pylint(code: str) -> str:
    """运行pylint检查Python代码质量，返回检查结果"""
    # 写入临时文件
    with open("/tmp/review_code.py", "w") as f:
        f.write(code)

    result = subprocess.run(
        ["pylint", "/tmp/review_code.py", "--output-format=text"],
        capture_output=True,
        text=True,
        timeout=30,
    )
    return result.stdout or result.stderr or "检查通过，无问题"


@tool
def run_bandit(code: str) -> str:
    """运行bandit扫描Python代码安全漏洞，返回扫描结果"""
    with open("/tmp/review_code.py", "w") as f:
        f.write(code)

    result = subprocess.run(
        ["bandit", "/tmp/review_code.py", "-f", "text"],
        capture_output=True,
        text=True,
        timeout=30,
    )
    return result.stdout or result.stderr or "未发现安全问题"


# 把工具绑定给LLM
tools = [run_pylint, run_bandit]
llm_with_tools = llm.bind_tools(tools)
```

这样Agent不仅依赖LLM的判断，还能调用真实的代码分析工具，结果更可靠。

## 用 Dify/Coze 搭建业务流程 Agent（低代码方式）

不是所有Agent都需要写代码。对于业务流程类的Agent，低代码平台效率更高。

### 适合的场景

- 客服工单自动分类和路由
- 内部审批流程自动化（请假审批、报销审批的辅助）
- 定期报告自动生成（日报、周报汇总）
- 数据查询Bot（对接内部数据库，自然语言查数据）

这类场景的共同特点：流程相对固定，需要对接外部系统，但逻辑不复杂。

### Dify 搭建流程

Dify 是一个开源的LLM应用开发平台，提供可视化的工作流编排。

**搭建一个"智能客服工单处理Agent"的步骤：**

1. **创建应用** — 登录Dify，创建新的"工作流"类型应用

2. **设计流程节点**：
   - **开始节点**：接收用户输入的工单内容
   - **LLM节点 - 分类**：让模型判断工单类型（技术问题/账务问题/投诉/咨询），输出结构化的JSON
   - **条件分支节点**：根据分类结果走不同分支
   - **HTTP请求节点**：调用内部API查询用户信息、订单信息
   - **LLM节点 - 回复生成**：基于分类结果和查询到的信息，生成回复草稿
   - **结束节点**：输出回复内容和建议的处理方式

3. **配置每个节点的参数**：
   - LLM节点里写好System Prompt，要求输出JSON格式
   - HTTP请求节点配置好内部API的地址、认证信息
   - 条件分支节点设置匹配规则

4. **测试和发布** — Dify提供在线调试功能，可以输入测试工单看每个节点的输出

### Coze 搭建流程

Coze（字节跳动出品）操作流程类似，特色是内置了很多现成的插件（搜索、画图、代码执行等），集成飞书/Discord比较方便。

搭建步骤大同小异：创建Bot -> 配置人设Prompt -> 添加插件（选你需要的工具） -> 配置工作流（如果需要多步骤） -> 测试发布。

**选择建议**：如果你要私有部署、对数据安全有要求，选Dify（开源可自部署）。如果追求开箱即用、主要在国内使用，选Coze。

## Agent 与现有系统集成

Agent搭好了，怎么接入你现有的系统？三种常见模式：

### 1. API 对接（同步）

最直接的方式。Agent暴露HTTP API，业务系统直接调用。

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

# 前面定义的review graph
review_agent = build_review_graph()


class ReviewRequest(BaseModel):
    code: str
    language: str = "python"


class ReviewResponse(BaseModel):
    report: str
    style_issues: list[str]
    security_issues: list[str]
    performance_issues: list[str]


@app.post("/api/review", response_model=ReviewResponse)
async def review_code(request: ReviewRequest):
    result = review_agent.invoke({
        "code": request.code,
        "language": request.language,
        "style_issues": [],
        "security_issues": [],
        "performance_issues": [],
        "report": "",
    })

    return ReviewResponse(
        report=result["report"],
        style_issues=result["style_issues"],
        security_issues=result["security_issues"],
        performance_issues=result["performance_issues"],
    )
```

适合：实时性要求高、处理时间短（<30秒）的场景。

### 2. Webhook（异步通知）

Agent处理完任务后，主动回调通知业务系统。适合处理时间较长的任务。

```python
import httpx
import asyncio


async def process_and_notify(task_id: str, code: str, callback_url: str):
    """异步处理代码审查，完成后通过Webhook通知"""
    try:
        result = review_agent.invoke({
            "code": code,
            "language": "python",
            "style_issues": [],
            "security_issues": [],
            "performance_issues": [],
            "report": "",
        })

        # 处理完成，回调通知
        async with httpx.AsyncClient() as client:
            await client.post(
                callback_url,
                json={
                    "task_id": task_id,
                    "status": "completed",
                    "report": result["report"],
                },
                timeout=10,
            )
    except Exception as e:
        async with httpx.AsyncClient() as client:
            await client.post(
                callback_url,
                json={
                    "task_id": task_id,
                    "status": "failed",
                    "error": str(e),
                },
                timeout=10,
            )


@app.post("/api/review/async")
async def review_code_async(request: dict):
    task_id = str(uuid.uuid4())
    callback_url = request.get("callback_url")

    # 后台执行，不阻塞响应
    asyncio.create_task(
        process_and_notify(task_id, request["code"], callback_url)
    )

    return {"task_id": task_id, "status": "processing"}
```

### 3. 消息队列（解耦）

用 RabbitMQ 或 Redis Stream 做中间件，生产者发布任务，Agent消费处理。这是最健壮的方式，适合高并发和需要重试的场景。

```python
import redis
import json

r = redis.Redis(host="localhost", port=6379)

# 消费者 —— Agent 服务
def consume_review_tasks():
    while True:
        # 从队列中阻塞读取任务
        _, message = r.brpop("review_tasks")
        task = json.loads(message)

        try:
            result = review_agent.invoke({
                "code": task["code"],
                "language": task.get("language", "python"),
                "style_issues": [],
                "security_issues": [],
                "performance_issues": [],
                "report": "",
            })

            # 结果写入结果队列
            r.lpush(
                f"review_results:{task['task_id']}",
                json.dumps({"status": "completed", "report": result["report"]}),
            )
        except Exception as e:
            r.lpush(
                f"review_results:{task['task_id']}",
                json.dumps({"status": "failed", "error": str(e)}),
            )


# 生产者 —— 业务系统
def submit_review_task(code: str, task_id: str):
    r.lpush(
        "review_tasks",
        json.dumps({"task_id": task_id, "code": code}),
    )
```

三种方式不是互斥的，一个系统里可能同时用到。简单场景用API直调，复杂场景用消息队列，需要实时通知的加上Webhook。根据你的实际需求选就行。
