# 4.1 AI辅助编程认知

作为开发者，你大概率已经在ChatGPT里粘贴过代码让它帮你debug，或者让它帮你写个正则表达式。但AI辅助编程这件事，远不止"把代码丢给聊天机器人"这么简单。过去两年，这个领域已经进化出了一套完整的工具链和方法论，值得你系统地了解一下。

## 代码补全模型是怎么工作的

所有AI编程工具的底层，都是大语言模型。但代码补全和你在ChatGPT里聊天有一个关键区别：**上下文来源不同**。

在ChatGPT里，上下文就是你输入的对话。而在IDE里做代码补全时，模型的上下文来自多个维度：当前文件的代码、光标位置前后的内容、同一项目中其他已打开或相关的文件、import语句暗示的依赖关系，甚至是文件名和目录结构。模型会把这些信息拼成一个prompt，发给后端模型，再把生成结果插入到你的光标位置。

这就是为什么同一个模型，在ChatGPT里写代码和在Copilot里写代码，效果差很多。不是模型变了，是喂给模型的上下文完全不一样。

最近一年，AI编程工具从"补全模式"进化到了"Agent模式"。补全模式是你写一行代码，AI预测下一行；Agent模式则是你用自然语言描述一个任务，AI自主规划步骤，创建文件、修改代码、运行测试，甚至还会在出错时自动调试。两种模式不是替代关系，而是适用于不同粒度的任务。

## 主流工具深度对比

### Claude Code

Claude Code是我用得最多、也最推荐深入掌握的AI编程工具。它是Anthropic出品的CLI工具，直接在终端里运行——没有图形界面，纯靠文字交互（可通过插件集成进IDE）。

听起来好像很原始，但实际用起来你会发现它的Agent能力是目前最强的。你给它一个任务，比如"把这个项目的Express路由全部迁移到Fastify"，它会自己读代码、理解结构、制定计划、逐步修改、跑测试验证。它对整个项目的理解深度，比IDE内嵌的AI工具更好，因为它可以自由地浏览整个代码库，不受IDE上下文窗口的限制。

Claude Code的**CLAUDE.md机制**是一个非常优秀的设计。你在项目根目录放一个CLAUDE.md文件，写明项目的技术栈、代码规范、架构约定，Claude Code每次启动都会读取它，相当于给AI一个持久的"项目记忆"。还支持用`@path/to/file`语法引用其他文件，可以把不同维度的规则拆分管理。

2026年2月随Opus 4.6发布的**Agent Teams（蜂群模式）** 是一个里程碑式的功能。传统的AI编程是一个Agent串行处理任务，Agent Teams让一个Claude Code实例作为Team Lead，创建多个Teammate实例并行工作。每个Teammate在独立的Git Worktree中操作，互不冲突——前端Agent改组件的同时，后端Agent改API，测试Agent写测试用例，最后合并。Anthropic的安全团队用16个并行Agent在两周内构建了一个C编译器（约10万行Rust代码）。启用方式是设置环境变量`CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`。

**我的判断：** Claude Code适合做中大型的代码重构、跨文件修改、项目级别的任务。Agent Teams功能更是让它在大规模并行开发场景中几乎没有对手。日常写代码可以配合IDE工具，遇到大活儿用Claude Code。

### Google Antigravity

Antigravity是Google在2025年底随Gemini 3发布的AI原生IDE，设计理念是**"Agent-First"**——不是在编辑器里加AI功能，而是把整个IDE设计成一个Agent调度平台。

它基于VS Code的代码做了深度改造。最核心的差异点在于Manager View：你可以同时派出多个Agent并行处理不同任务（比如五个Agent同时修五个bug），并且Agent之间共享一个**自我改进的知识库**——Agent在工作中学到的模式会回馈给知识库，其他Agent可以复用。你还可以像在Google Doc里批注一样，直接在Agent的产出上加评论反馈，AI会即时吸收这些反馈，无需重启任务。

Antigravity支持多种模型：Gemini 3 Pro/Flash/Deep Think，以及Anthropic的Claude Sonnet 4.5和Claude Opus 4.5/4.6。目前对个人Gmail用户免费，Gemini 3 Pro的额度很慷慨。

**我的判断：** Antigravity代表了AI IDE的一个新方向——从"辅助编码"到"管理Agent团队"。但它目前稳定性还需要提升，也有安全研究机构指出了一些漏洞。适合尝鲜和探索，生产环境暂时还是用更成熟的工具。

### Cursor

Cursor是目前综合体验最成熟的AI编程IDE。它fork了VS Code，所以你的快捷键、插件大部分都能用，迁移成本不高。但它绝不只是"VS Code装了个AI插件"。

Cursor的设计哲学是**把AI作为IDE的一等公民**。Cmd+K可以直接在代码中用自然语言下指令；Composer模式可以跨多个文件做修改；它的上下文管理能力很强，你可以用`@`符号引用文件、文档、甚至网页作为上下文。Agent模式能读取终端输出，代码跑不通时会自动分析错误、修改、再次运行。

`.cursorrules`文件类似Claude Code的CLAUDE.md，给AI一份项目说明书。

**我的判断：** 如果你的日常工作是在IDE里写代码，Cursor是目前最稳定的选择。跟Claude Code不是竞争关系，更像是互补——日常写代码用Cursor，大规模重构和项目级任务用Claude Code。

### GitHub Copilot

Copilot是这个赛道的开创者，现在已经是很多团队的标配。Copilot Pro+版本支持GPT-5、Claude Opus 4等多种模型选择。它的核心能力还是**行级和函数级的代码补全**，写代码时按Tab接受建议，体验非常顺滑。

Copilot的优势在于跟GitHub生态的深度整合，以及对主流IDE的全面支持（VS Code、JetBrains、Vim等）。Copilot Chat加入后对话能力也不错了。

**我的判断：** 适合团队已有固定IDE工作流、不想切换工具的场景。它是一个很好的"辅助驾驶"，但Agent能力跟Claude Code和Antigravity比还有差距。

### 新兴工具简评

**Windsurf**（原Codeium）在代码补全的响应速度和性价比上做得不错，"Cascade"功能支持全流程AI辅助。**Trae**（字节出品）对国内开发者比较友好，中文理解能力好，集成了国内模型的访问。**Augment Code** 在企业级代码库的理解上有自己的特色。

## AI编程的能力边界

搞清楚AI擅长什么、不擅长什么，比学会任何一个工具都重要。

**AI写得好的代码：** 样板代码（CRUD接口、数据模型定义）、单元测试（给定函数写测试用例）、工具函数（日期格式化、数据转换）、文档和注释、正则表达式、SQL查询、配置文件。这些任务有大量的训练样本，模式也比较固定。

**AI需要你盯着的代码：** 复杂业务逻辑（涉及多个系统交互的流程编排，AI很容易遗漏边界条件）、安全相关代码（认证、授权、加密，AI生成的代码可能有漏洞但看起来"像那么回事"）、性能敏感代码（AI不了解你的数据规模和访问模式）、涉及并发和状态管理的代码。

一个我自己总结的原则：**AI生成的代码，你至少要能看懂它在干什么。** 如果AI写了一段代码你完全看不懂但跑起来了，那不是效率提升，那是埋了个定时炸弹。

## AI生成代码的质量与安全

AI生成的代码有几个常见的质量问题需要警惕。

第一是**过时的API和依赖**。模型的训练数据有截止日期，它可能会用已经废弃的函数或者有已知漏洞的库版本。

第二是**看起来对但逻辑有细微错误的代码**。比如AI写一个分页查询，大部分情况跑得好好的，但当page为0的时候会出bug。这种错误比语法错误危险得多，因为代码review时很容易放过。

第三是**安全漏洞**。研究表明，AI生成的代码中SQL注入、XSS、路径遍历等常见漏洞的出现率并不低。AI不会主动考虑安全威胁模型，它只是生成"最可能的下一段代码"。

```python
# AI可能生成这样的代码——看起来没问题，但有SQL注入风险
def get_user(username):
    query = f"SELECT * FROM users WHERE username = '{username}'"
    return db.execute(query)

# 你需要改成参数化查询
def get_user(username):
    query = "SELECT * FROM users WHERE username = %s"
    return db.execute(query, (username,))
```

