# 4.2 AI辅助开发方法论

知道了有哪些AI编程工具之后，更重要的问题是：怎么把它们真正融入你的开发流程？不是在写代码时偶尔问AI一句，而是系统性地用AI重构你的整个工作方式。

## AI驱动的开发工作流

一个完整的开发任务，从需求到上线，每个环节AI都能介入，但介入的方式和深度不一样。

**需求理解阶段。** 拿到一个需求文档或Jira工单，先丢给AI让它帮你梳理。不是让它替你理解需求，而是让它帮你发现你可能忽略的点。比如："帮我分析这个需求，列出可能遗漏的边界条件和需要跟产品经理确认的问题。"AI经常能提出一些你一时没想到的corner case。

**方案设计阶段。** 你心里有个大概的技术方案，让AI帮你完善细节或者做方案对比。比如："我要实现一个消息队列的消费者，方案A用Redis Stream，方案B用RabbitMQ，请对比两个方案在可靠性、吞吐量、运维复杂度方面的差异。"AI给出的对比不一定全对，但能帮你快速建立一个比较框架，省去大量Google的时间。

**编码阶段。** 这是AI介入最深的环节。样板代码直接让AI生成；复杂逻辑先写伪代码注释，让AI帮你填充实现；遇到不熟悉的API，直接问AI要示例代码。但记住，复杂的业务逻辑自己写，让AI帮你写测试来验证。

**Code Review阶段。** 提交PR之前，先让AI review一遍。把diff丢给它，让它关注：有没有安全漏洞、有没有明显的性能问题、有没有违反项目的编码规范。AI的review不能替代人的review，但它能在人review之前过滤掉一批低级问题，让人把注意力放在业务逻辑和架构设计上。

**调试阶段。** 遇到报错，把错误堆栈和相关代码丢给AI。这可能是AI辅助开发里ROI最高的场景——很多时候AI能在几秒钟内定位到你可能花半小时才能找到的问题。特别是那些你不熟悉的框架或库报出的错误，AI见过的case比你多得多。

**文档阶段。** 写完代码让AI生成API文档、README、代码注释。这些本来就是大部分开发者不爱干但又必须干的活，交给AI再合适不过了。

## 面向开发者的Prompt技巧

通识篇讲过基本的提示词工程，但面向代码场景，有一些更具体的技巧。

**第一，描述需求时要给出明确的技术约束。** 别说"写一个用户登录接口"，要说"用Node.js + Express写一个用户登录接口，使用JWT做认证，密码用bcrypt加密，需要做参数校验，返回格式遵循RESTful规范"。约束越明确，生成的代码越接近你想要的。

```
// 差的prompt
"写一个分页查询的函数"

// 好的prompt
"用TypeScript写一个分页查询函数，要求：
- 入参：page(从1开始)、pageSize、总数据列表
- 返回值包含：当前页数据、总页数、是否有下一页
- 加上完整的类型定义
- pageSize默认20，最大100
- 对无效入参做防御性处理"
```

**第二，提供充足的上下文。** 如果你要AI修改一段代码，别只给它那一个函数，把相关的类型定义、调用方的代码、甚至是数据库schema一起给它。AI不怕上下文多，怕的是关键信息缺失然后自己瞎猜。

**第三，分步让AI完成复杂任务。** 一次让AI"设计并实现一个完整的订单系统"，结果一定很烂。但你可以分步来：先让它设计数据模型，你review完之后再让它写Repository层，然后是Service层，最后是Controller层。每一步都基于上一步确认后的结果，质量会高很多。

**第四，让AI解释它的代码。** 特别是当AI生成了一段你不太确定的逻辑，追问一句"解释一下这段代码的执行流程，以及为什么用这种方式实现而不是XXX"。这既能帮你验证代码的正确性，也是一个学习的过程。

## AI结对编程：什么时候开，什么时候关

AI辅助不是越多越好。有些时候你应该主动关掉AI提示。

**适合开着AI的场景：** 写新功能的脚手架代码、写CRUD接口、写单元测试、处理你不熟悉的技术栈或API、做代码迁移和重构、写配置文件和部署脚本。这些场景下AI能帮你省大量时间，而且出错了容易发现。

**建议关掉AI的场景：** 你正在深度思考一个架构问题（AI的建议会打断你的思路）、你在学习一个新概念想自己理解透（太依赖AI会变成"面向AI编程"而不是真正学会）、你在处理一个微妙的并发bug（AI的建议往往是表面补丁，不解决根本问题）。

一个实用的工作节奏是：**先花10分钟自己想清楚要做什么、大概怎么做，然后打开AI帮你快速实现。** 如果你连要做什么都不清楚就开始跟AI对话，很容易被AI带着走，最终写出一堆不知道对不对的代码。

## 代码上下文管理

让AI理解你的项目，是提升AI编程效果最有杠杆的事情。

**Cursor的.cursorrules文件。** 在项目根目录创建`.cursorrules`文件，写入项目的编码规范和技术约定。Cursor在每次对话时都会把它作为上下文传给模型。

```markdown
# .cursorrules 示例

## 技术栈
- 前端：React 18 + TypeScript + TailwindCSS
- 后端：Node.js + Fastify + Prisma + PostgreSQL
- 测试：Vitest + Testing Library

## 编码规范
- 组件使用函数式组件 + hooks，不用class组件
- API返回格式统一为 { code, data, message }
- 错误处理统一用自定义的AppError类
- 数据库查询统一通过Repository层，Service层不直接操作Prisma

## 目录结构
- src/modules/[模块名]/ 下包含 controller、service、repository、dto、entity
- src/common/ 存放公共工具、中间件、装饰器
```

**Claude Code的CLAUDE.md。** 类似的机制，但Claude Code的读取范围更广——它会读取项目根目录和你home目录下的CLAUDE.md，你可以分层管理：全局的放通用偏好（比如你喜欢的代码风格），项目级的放项目特定的约定。

**项目文档引用。** 在Cursor里用`@`引用项目文档（设计文档、API文档、数据库ERD），Claude Code里可以直接让它读取特定文件。好的项目文档不仅帮人理解项目，也帮AI理解项目。如果你的项目连一份像样的README都没有，不管是人还是AI来接手都会很痛苦。

这些上下文管理的工作，前期投入半小时到一小时，后续每次AI交互的质量都会显著提升。这是一笔很划算的投入。
