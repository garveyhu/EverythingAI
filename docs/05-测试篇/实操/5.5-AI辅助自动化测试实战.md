# 5.5 AI辅助自动化测试实战

自动化测试是AI能力提升最直观的领域。以前写一个Playwright脚本，你得自己研究页面结构、找定位器、写断言，一个稍微复杂的页面操作可能要调试大半天。现在你把需求描述给AI，它几分钟就能输出一个可运行的脚本框架。

但"能运行"和"好用"之间还有距离。这一节我们聊怎么让AI写出真正可靠的自动化测试代码，以及当脚本需要维护时怎么用AI来加速。

## 用AI编写Playwright自动化测试脚本

Playwright是目前最受欢迎的Web自动化测试框架之一。让AI帮你写Playwright脚本，关键在于你给它的信息要够充分。

### Prompt模板：从测试用例到Playwright脚本

```
你是一位自动化测试工程师，精通Playwright和TypeScript。请根据以下测试用例编写Playwright自动化测试脚本。

【测试用例】
用例标题：验证已支付待发货订单的退款申请流程
前置条件：用户已登录，存在一笔已支付待发货的订单（订单号：TEST202501001，金额：299.00元）
操作步骤：
1. 进入"我的订单"页面
2. 找到目标订单，点击"申请退款"按钮
3. 在退款原因下拉框选择"不想要了"
4. 在退款说明文本框输入"测试退款流程"
5. 点击"提交退款申请"按钮
预期结果：
- 页面显示"退款申请已提交"的成功提示
- 订单状态变更为"退款审核中"
- 退款金额显示为299.00元

【技术要求】
- 使用Playwright + TypeScript
- 使用Page Object模式组织代码
- 元素定位优先使用data-testid，其次使用文本内容定位
- 添加合理的等待和断言
- 添加必要的注释
```

AI通常会输出类似这样的代码：

```typescript
// page-objects/OrderPage.ts
import { Page, Locator, expect } from '@playwright/test';

export class OrderPage {
  readonly page: Page;
  readonly refundButton: Locator;
  readonly reasonSelect: Locator;
  readonly descriptionInput: Locator;
  readonly submitButton: Locator;
  readonly successMessage: Locator;
  readonly orderStatus: Locator;
  readonly refundAmount: Locator;

  constructor(page: Page) {
    this.page = page;
    this.refundButton = page.locator('[data-testid="refund-button"]');
    this.reasonSelect = page.locator('[data-testid="refund-reason"]');
    this.descriptionInput = page.locator('[data-testid="refund-description"]');
    this.submitButton = page.locator('[data-testid="submit-refund"]');
    this.successMessage = page.locator('[data-testid="success-message"]');
    this.orderStatus = page.locator('[data-testid="order-status"]');
    this.refundAmount = page.locator('[data-testid="refund-amount"]');
  }

  async navigateToOrders() {
    await this.page.goto('/my/orders');
    await this.page.waitForLoadState('networkidle');
  }

  async applyRefund(orderId: string, reason: string, description: string) {
    // 找到目标订单的退款按钮
    const orderRow = this.page.locator(`[data-testid="order-${orderId}"]`);
    await orderRow.locator('[data-testid="refund-button"]').click();

    // 填写退款信息
    await this.reasonSelect.selectOption({ label: reason });
    await this.descriptionInput.fill(description);
    await this.submitButton.click();
  }
}

// tests/refund.spec.ts
import { test, expect } from '@playwright/test';
import { OrderPage } from '../page-objects/OrderPage';

test.describe('订单退款流程', () => {
  let orderPage: OrderPage;

  test.beforeEach(async ({ page }) => {
    orderPage = new OrderPage(page);
    // 假设已通过登录fixture完成登录
    await orderPage.navigateToOrders();
  });

  test('已支付待发货订单应能成功提交退款申请', async ({ page }) => {
    await orderPage.applyRefund('TEST202501001', '不想要了', '测试退款流程');

    // 验证成功提示
    await expect(orderPage.successMessage).toContainText('退款申请已提交');
    // 验证订单状态变更
    await expect(orderPage.orderStatus).toContainText('退款审核中');
    // 验证退款金额
    await expect(orderPage.refundAmount).toContainText('299.00');
  });
});
```

拿到AI生成的代码后，你需要做几件事：核实元素定位器是否与你们实际页面一致（data-testid的命名、页面URL等）；检查等待策略是否合理（有没有硬编码的sleep，等待条件是否充分）；确认断言是否真正验证了你想验证的东西。

### 提升AI生成脚本质量的技巧

如果你能把页面的HTML结构片段一起提供给AI，生成的定位器会准确得多。你可以在浏览器DevTools里复制关键元素的HTML，放到Prompt里：

```
【页面关键元素的HTML结构】
<div class="order-item" data-order-id="TEST202501001">
  <span class="order-status">已支付</span>
  <span class="order-amount">¥299.00</span>
  <button class="btn-refund" data-testid="btn-refund">申请退款</button>
</div>

请根据上述实际HTML结构调整元素定位器。
```

这样AI就不用猜了，它会直接使用真实的class名、data属性和页面结构来写定位器。

## 用AI做接口测试：从API文档生成测试集

接口测试是另一个AI非常擅长的场景。如果你有Swagger文档或API规格说明，AI可以直接帮你生成一整套测试集。

### Prompt模板：从API文档生成接口测试

```
你是一位接口测试专家。请根据以下API文档生成完整的接口测试用例和测试脚本。

【API文档】
接口名称：提交退款申请
URL：POST /api/v1/orders/{orderId}/refund
请求头：Authorization: Bearer {token}
请求体（JSON）：
{
  "reason": "string, 必填, 退款原因枚举值：NOT_NEEDED/QUALITY_ISSUE/WRONG_ITEM/OTHER",
  "description": "string, 必填, 10-500字符",
  "refund_amount": "number, 选填, 不传则默认全额退款"
}
成功响应（200）：
{
  "code": 0,
  "data": { "refund_id": "string", "status": "PENDING", "estimated_time": "string" }
}
错误响应：
- 400：参数校验失败
- 401：未登录
- 403：无权操作该订单
- 404：订单不存在
- 409：该订单已有进行中的退款申请

【要求】
1. 使用Python + pytest + requests编写
2. 覆盖所有正常和异常响应码
3. 覆盖请求参数的边界值
4. 包含参数化测试（多组数据驱动）
5. 添加清晰的中文注释
```

AI会生成一套包含正向和逆向测试的完整脚本，涵盖参数校验、权限控制、状态冲突等场景。你拿到代码后需要调整的主要是：实际的BaseURL和认证方式、测试数据的准备和清理逻辑、以及与你们CI/CD流水线的集成方式。

### 批量接口测试生成

如果你有完整的Swagger JSON文件，可以用一个更高效的方式：

```
我有一份Swagger JSON格式的API文档（已粘贴在下方）。请为其中的以下接口分别生成测试用例：
1. POST /api/v1/orders/{orderId}/refund
2. GET /api/v1/refunds/{refundId}
3. PUT /api/v1/refunds/{refundId}/approve

对每个接口，请生成：
- 正向测试（正常参数、正常流程）
- 参数校验测试（缺少必填参数、参数格式错误、参数越界）
- 权限测试（无token、无效token、无权限用户）
- 业务逻辑测试（基于接口的业务约束）

使用pytest参数化格式组织，方便后续扩展测试数据。
```

## AI辅助测试脚本维护与修复

自动化测试最头疼的不是写脚本，而是维护脚本。页面改了个布局、接口加了个字段、流程多了一步——这些变更都可能导致已有的测试脚本失败。AI在这个环节能帮大忙。

### 场景一：页面改版导致定位器失效

```
我的Playwright测试脚本在执行时报错，因为页面改版后元素定位器失效了。

【报错信息】
Error: locator.click: Error: strict mode violation: locator('[data-testid="btn-refund"]') resolved to 0 elements

【原来的页面结构】
<button class="btn-refund" data-testid="btn-refund">申请退款</button>

【改版后的页面结构】
<div class="refund-action">
  <a href="#" class="link-refund" role="button">
    <span class="icon-refund"></span>
    <span>申请退款</span>
  </a>
</div>

【原来的脚本代码】
（粘贴相关的Page Object代码）

请帮我更新定位器和相关代码，保持与原有Page Object模式一致。
```

### 场景二：接口变更导致测试失败

```
我们的退款API升级了v2版本，接口有以下变更：
1. URL从 /api/v1/orders/{orderId}/refund 改为 /api/v2/orders/{orderId}/refunds
2. 请求体新增必填字段 "refund_type": "FULL" | "PARTIAL"
3. 响应体中 "estimated_time" 字段从字符串改为时间戳格式（Unix毫秒）
4. 新增响应码 422：退款类型与订单不匹配

以下是现有的测试代码：
（粘贴现有测试代码）

请帮我更新测试代码以适配v2接口，同时为新增的字段和响应码添加测试用例。
```

这种场景下AI的价值在于：它能同时理解"变更内容"和"现有代码"，然后精准地做出修改，不会改错不该改的地方。你手动做这些更新也能做，但当变更涉及多个文件、多条测试用例时，AI能帮你大幅节省时间。

## 实际工作流：自动化测试的AI协作模式

把上面的内容串成一个日常工作流。

**写新脚本时：** 先写清楚测试用例（可以用5.4的方法让AI帮你生成），然后把用例+页面结构/API文档给AI，让它生成脚本初稿。你review代码、调整定位器和数据、在本地跑通、然后提交。

**维护旧脚本时：** CI/CD报错了，把报错信息和相关的代码、页面变更信息一起给AI。让它帮你定位问题、给出修改方案。你确认方案合理后执行修改。

**重构脚本时：** 如果一批旧脚本写得比较糟糕（没有Page Object、硬编码太多、没有合理的等待），你可以把代码批量丢给AI，让它按统一的规范做重构。这比你一个文件一个文件改要快得多。

一个提醒：AI生成的自动化测试代码一定要在本地实际运行验证后再提交。AI不能真正"看到"你的页面或调用你的接口，它生成的代码是基于你的描述做的"最佳猜测"。大方向通常没问题，但细节上（比如某个元素需要滚动到可见区域才能点击、某个接口需要特定的请求顺序）往往需要你手动微调。
